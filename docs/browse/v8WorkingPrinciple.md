---
editLink: false
---

# 编译器（Compiler）和 解释器（Interpreter）

编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译 c c++ Go等

解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行 javascript python等

![1720001190604](images/v8WorkingPrinciple/1720001190604.png)

**暂时无法在飞书文档外展示此内容**

1. 在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析、生成抽象语法树、优化代码、最后生成处理器可执行的机器码。编译成功会生成一个可执行的文件。后续运行这个可执行的文件即可。
2. 在解释型语言的解释过程中，解释器会对源码依次进行词法分析、语法分析、生成抽象树，基于抽象树生成字节码，根据字节码执行程序，输出结果。

# 抽象语法树（AST）

将源代码转化为抽象树，并执行上下文，

Bable是一个被广泛使用的代码转码器，可以将ES6代码转为ES5代码。

Bable的工作原理就是先将ES6源码转换为AST，然后再将ES6语法的AST转换为ES5语法的AST，最后利用ES5的AST生成javascript源代码

ESLint是一个用来检查javascript编写规范的插件，其检测流程也是需要将源码转换为AST，然后再利用AST来检查代码规范化的问题

生成AST需要两个阶段：

* 分词——词法分析：

将一行行的源码拆解成一个个token——语法上不可再分的最小单个字符或字符串。 将标识符 变量 运算符 字符串等 处理成不同的token

* 解析——语法分析：

将生成的token数据，根据语法规则转为AST。源码存在语法错误，到这会被终止，并抛出一个 语法错误

有了AST后，v8就会生成该段代码的执行上下文。

# 字节码（Bytecode）

有了AST和执行上下文，解释器Ignition会根据AST生成字节码，并解释执行字节码。

在最开始v8是直接将AST转换为机器码，由于执行机器码的效率是非常高效的，所以效果一直很好。但随着chrome在手机上的广泛普及，机器码占用内存的问题暴露出来了，v8需要消耗大量的内存来存放转换后的机器码。为了解决这个问题v8团队重构了引擎架构，引入了字节码，并抛弃了之前的编译器。

**字节码是介于****AST****和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过****解释器****将其转换为机器码后才能执行**

如果有一段第一次执行的字节码，解释器Ignition会逐条解释执行。在执行字节码的过程中，如果发现有热代码（HotSpot）（一段代码被重复多次执行），后台编译器TurboFan就会把该段热点的字节码编译成高效的机器码，然后当再次执行到这段被优化的代码时，只需要执行编译后的机器码就可以，大大提升了代码的执行效率

# 即时编译器（JIT）

字节码配合解释器和编译器的技术，就叫即时编译

在v8中，指的是解释器Ignition在解释执行字节码的同时，收集代码信息，当发现某一部分代码变热后，TurboFan编译器就会将这些热代码转换为机器码，并把转换后的机器码保存起来，用于后续使用。



# 浏览器页面是由消息队列和事件循环驱动的
每个渲染进程都有一个主线程，用来处理各种计算（构建DOM树，计算styleSheet，生成布局树， 分层，图层绘制， 栅格化， 合成，显示），同时还要处理javascript任务以及各种输入事件。要让这么多不同类型的任务在主线程上有条不紊的执行，就需要一个系统统筹调度。
![屏幕截图 2024-09-02 181336](https://github.com/user-attachments/assets/c30a43af-4927-4945-868d-d664d5bfc68a)

消息队列是一种数据结构，可以存放要执行的任务，先进先出。
消息队列中的任务类型
- 输入事件（键盘事件、鼠标事件）等
- 微任务
- 文件读写
- WebSocket
- JavaScript定时器
- ...
主线程执行的任务，全部来自于消息队列。
所有的任务都是在单线程中执行的。每次只能执行一个任务，其他任务都处于等待状态。所以使用事件循环，从消息队列的头部取出要执行的任务，执行完毕再取下一个任务，直到消息队列为空。
假设渲染主线程正在渲染页面，同时又有鼠标事件，那该怎么处理呢。
1. 先处理鼠标事件，将会阻碍页面渲染，用户体验将会很差--怎么每次点下鼠标怎么就会卡呢
2. 排队？插入到消息队列中？——  这种方式虽然更差，像这种用户主动事件，需要立刻触发，要是从消息队列中排队到事件循环在执行，给用户感觉就是——无响应体验更差
解决方法：使用微任务，在当前宏任务结束，后调用微任务。

# setTimeOut
- 为了执行定时器的实现，浏览器增加了延时队列
- 由于消息队列排队和一些系统级别的限制，通过setTimeOut设置的回调任务并非总是可以实时地被执行
- 定时器中存在的陷阱
  - 当前任务执行时间过久，会影响延迟到期定时任务的执行（任务是单线程执行）
  - 如果setTimeOut存在嵌套调用，那么系统会设置最短时间间隔为4毫秒
  嵌套调用超过5次以上，后面每次的调用最小时间间隔是4毫秒。在chrome中，定时器被嵌套调用5次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于4毫秒，浏览器会将每次调用的时间间隔设置为4毫秒。
  - 未激活的页面，setTimeOut执行最小间隔是1000毫秒
  未被激活的页面中定时器最小值大于1000毫秒，为了优化后台页面的加载损耗降低耗电量。
  - 延时执行时间有最大值（24.8天）
  浏览器以32个bit来存储延时值，大于32bit（2^32取正数）的值，大于这个值时，就会溢出，导致定时器会立即执行。
  - setTimeOut设置的回调函数中this指向全局
    - 可使用匿名函数或箭头函数
    - 使用bind方法
# XMLHttpRequest
回调函数 ：将一个函数作为参数传递给另一个函数，那个作为参数的函数就是回调函数。
回调函数在主函数返回之前执行——同步函数
回调函数没有在主函数内被调用——异步函数

系统调用栈的信息可以通过：chrom://tracing/来抓取

# 宏任务 微任务
宏任务：
普通消息队列和延时队列中的任务都是宏任务
微任务：
- 把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。
- 执行时机是在主函数执行结束之后，当前宏任务结束之前执行回调函数，微任务形式的体现。
微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。
微任务，在v8创建全局执行上下文同时，v8也会在那部创建一个微任务队列。每个宏任务都关联一个微任务队列。
# 监听DOM变化方法
Mutation Event 采用了观察者的设计模式，当DOM有变动时就会立刻触发相应的事件——同步回调
这种方式有很严重的性能问题，每次DOM变动，渲染引擎都会去调用Javascript，会产生大量的性能开销。
为了解决Mutation Event 由于同步调用Javascript而造成的性能问题，引入了MutationObserver来替代Mutation Event。
MutationObserver将响应函数改为异步调用，可以不用在每次DOM变化都触发一般调用，而是等多长DOM变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的DOM变化。这样即使频繁操作DOM，也不会对性能造成太大的影响。

# Promise
解决了什么问题：解决了异步编码风格的问题
异步编程的问题
- 代码逻辑不连续 - 异步回调
封装代码使用callback
- 回调地狱
  - 多层嵌套的问题
  - 每种任务的处理结果存在两种可能性，需要在每种任务执行结束后分别处理这两种可能性

使用promise 解决嵌套调用和多次错误处理
嵌套调用解决
- Promise 实现了回调函数的延时绑定
- 需要将回调函数onResolve的返回值穿透到最外层
多次错误处理
- promise对象的错误具有冒泡性质，会一直向后传递，直到被onReject函数处理或catch语句捕获为止。
```js
// 模拟promise的原理
funtion mypromise（fn）{
    var _onResolve = null
    var _onReject = null
    this.then = function(onResolve, onReject) {
        _onResolve = onResolve
    }
    function resolve(value) {
    //
        setTimeout(()=>{
        _onResolve(value)
        },0)
    }
    fn(resolve, null)
}
```
# async/await
ES7中引入了async/await，在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力
生成器   协程
生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的
function* dome(){
    console.log(1)
    yield 'generator 2'
    
    console.log(2)
    yield 'generator 2'
    
    console.log(3)
    yield 'generator 2'
    
    console.log(4)
    return 'generator 2'
}

console.log(0)

let dome1 = dome()
console.log(dome1.next().value)
console.log(11)
console.log(dome1.next().value)
console.log(12)
console.log(dome1.next().value)
console.log(13)
console.log(dome1.next().value)
console.log(14)


/*
0
 1
generator 2
 11
 2
generator 2
12
3
 generator 2
 13
 4
 generator 2
14

*/
生成器的具体使用方式：
- 在生成器函数内部执行一段代码，如果遇到yield关键字，javascript引擎将返回关键字后面的内容给外部，并暂停该函数的执行。
- 外部函数可以通过next方法恢复函数的执行
如何实现的暂停和恢复
协程是一种比线程更加轻量级的存在。跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。协程不是被操作系统内核控制的，而完全由程序所控制。不会消耗资源
协程的四点规则：
- 通过调用生成器函数来创建一个协程，创建之后，协程并没有立即执行
- 让协程执行，需要通过调用.next
- 当协程在执行的时候，可以通过yield关键字来暂停协程的执行，并返回主要信息给父协程
- 如果协程在执行期间，遇到了return关键字，javascript引擎会结束当前协程并将return后面的内容返回给父协程
async
通过异步执行并隐式返回Promise作为结果的函数
await
async function foo() {
    console.log(1)
    let a = await 100
    console.log(a)
    console.log(3)
}
console.log(0)
foo()
console.log(3)

/*
0
1
3
100
2
*/

